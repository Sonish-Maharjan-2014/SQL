CREATE TABLE employee(employeeid int primary key, firstname varchar(15), middlename varchar(20), lastname varchar(30), age int, salary int,location varchar(50) default 'gwarko'  not null);


CREATE TABLE employee(
employeeid int, 
firstname varchar(15), 
middlename varchar(20), 
lastname varchar(30), 
age int, 
salary int,
location varchar(50) default 'gwarko'  not null,
PRIMARY KEY(employeeid,firstname)
);

INSERT INTO employee(employeeid, firstname, middlename, lastname, age, salary, location) VALUES(1,"Ram","Kumar","Sharma",40,  40000);

SELECT * FROM employee;


CREATE TABLE employee(
employeeid int AUTO_INCREMENT, 
firstname varchar(15), 
middlename varchar(20), 
lastname varchar(30), 
age int, 
salary int,
location varchar(50) default 'gwarko'  not null,
PRIMARY KEY(employeeid,firstname)
);

Unique
============
only one primary key and primary key canno t have null value, it is use to get unique record

unique key can hold null value
mysql can hold many null but other compiler may hold only one null
 table has only one primary key but can have multiple unique key in the table
 
 
 
 
 CREATE TABLE employee(
employeeid int AUTO_INCREMENT, 
firstname varchar(15),  
lastname varchar(30), 
age int, 
PRIMARY KEY(firstname, lastname)
);

SELECT DISTINCT location FROM student;

SELECT * FROM studnet ORDER BY student_fname desc;


SELECT student_fname FROM student Order BY enrollment_date DESC LIMIT 1;


SELECT * FROM student WHERE student_fname LIKE '%/%%';

DISTINCT
==========
DISTINCT AND ORDERE BY DOESNT WORK AT THE SAME TIME

SELECT source_of_jonining FROM student;

ORDER OF EXECUTION
================
FROM (LOADING THE TABLE)

SELECT (PROJECTING source_of_joining)

SELECT source_of_joiningm enrollment_date FROM student;

SELECT source_of_joiningm enrollment_date FROM student ORDER BY enrollment_date;
================
FROM (LOADING THE TABLE)
SELECT (PROJECTING source_of_joining, enrollment_date);
ORDER BY (based on enrollment_date it will order by select source_of_joninig)


===========
SELECT DISTINCT source_of_joining FROM studnets ORDER BY enrollment_date;
ORDER OF EXECUTION
================
FROM

SELECT

DISTINCT

ORDER BY

========================================
AGGREGRATE FUNCTION
========================================
INPUT IS MANY LINE AND OUTPUT IS ONE LINE

COUNT

SELECT COUNT(*) FROM student;

SELECT COUNT(DISTINCT student_company) AS companies FROM student;

SELECT COUNT(DISTINCT source_of_joining) FROM student;

SELECT batch_date FROM student;

=====================================
GROUP BY
====================================
HOW MANY PEOPLE JOINED BY DIFFENERNT SOURCE LIKE 'FRIEND'

SELECT source_of_joining, COUNT(*) FROM student GROUP BY source_of_joining = 'friend';


location, source_of_joninig

SELECT location, source_of_joining FROM student;

SELECT location, source_of_joining, COUNT(*) FROM student GROUP BY location, source_of_joining;

SELECT selected_course, COUNT(*) FROM student GROUP BY selected_course;

=====================================
MIN & MAX
=====================================
SELECT MIN(years_of_exp) FROM student;

SELECT MAX(years_of_exp) FROM student;

Select source_of_joining, max(years_of_exp) from student group by source_of_joining;

SELECT SUM(SORCE OF JONING) FROM STUDENT;

AVG
=======
SELECT location, AVG(years_of_exp) FROM student group by location


GROUP BY
===============


data type
=============================================
Decimal
time stamp


MariaDB [trendytech]> create table course_new( courseid int not null, coursename varchar(30) not null, coursedurationmonths decimal(3,1) not null, coursefee int not null, changed_at timestamp default now() on update now()/current_timestamp(), primary key(courseid));

==========================================
Logical operator
========================
!= or <>--------> not equal to 
like and not like ----> eg: '%data%'
=
>=
>
<=
<
in
between and not betweeen -----> eg: between 8 and 12

select * from student where student_company = 'flipkart' or student_company = 'walmart' or student_company = 'microsoft';

select * from student where student_company in ('filpkart','walmart', 'microsoft');

case

select courseid,coursename,coursefee,
    -> case
    -> when coursedurationmonths > 4 then 'master'
    -> else 'diploma'
    -> end as course_type 
    -> from course_new;
    
select student_id, student_fname, student_lname, student_company,
    -> CASE
    -> WHEN student_company in ('flipkart', 'walmart', 'microsoft') then 'product_based'
    -> ELSE 'service_based'
    -> END as 'company_type'
    -> FROM student;

====================================================
JOINs
==============

tables
->student
student_fname, selected_course
->course
course_id, course_name


NESTED QUERY
================
select course_name from course where course_id = (select selected_course from student where student_fname = 'ram');

==================
select student_fname, course_name from student join course on student.selected_course = course.course_id;

BY DEFAULT join == inner join

inner join = matched in both table are only joined

outer join = every row in first table is linked with every data in second table unmatched records are set null

Left outer join
===============
all the matching record are considered + all the non matching recods in the left table which does not have match in the right

Right outer join
==============================
all the matching record are considered + all the non matching record in the right table which doesnt have mathc in the left

Full outer join (Union of left and right)
====================
all the matching record + non matchiing from left + non matching form right 

select student_fname, student_lname, course_name from student_latest right join course_latest on student_latest.selected_course = course_latest.course_id union select student_fname, student_lname, course_name from student_latest left join course_latest on student_latest.selected_course = course_latest.course_id; 


cross join
===============
select * from student join course;

=====================================================
where vs having clause in sql
===============================

select source_of_joining, count(*) as total from student group by source_of_joining;

select * from student natural join course on student.selected_course = course.course_id;

=======================================================
get data on the sourcee_of_joning
======================
select source_of_joining, count(*) as total from student group by source_of_joining

know the lead source through which student has joined
================================
select source_of_joining, count(*) as total from student group by source_of_joining where total>1;

where clause is used to filter individual record before aggregration so above query doesnt work so we use having clause

select source_of_joining, count(*) as total from student group by source_of_joining having total > 1;

having clause is use after the grouping method

only form linkdin

select source_of_joining, count(*) as total from student group by source_of_joining having source_of_joining ='linkedin';

optimized
=========
select source_of_joining, count(*) as total from student where source_of_joining ='total'
group by source_of_joining;

can we use both where and having in same query?
=========================
to know the location from which more than 1 student has joined and student experience is more than 10 years

select location, count(*) as total from student where years_of_exp > 10 group by location having total > 1;

where is used before group by and do filering on individual records

having is used after group by and do filtering on aggregrated records.

we use where and haviving in tha same query also

where is more performant than having

===========================================================

CREATE TABLE employee(
firstname varchar(40),
lastname varchar(30),
age int,
salary int,
);
========================
how many people are from each location and find average salary;
===========
select location,count(*) as total, avg(salary)  from employee_new group by location;

============
 select firstname, lastname, temptable.location,total, average from employee_new join 
(select location,count(*) as total, avg(salary) as average  from employee_new group by location) temptable 
on temptable.location = employee_new.location;

==================
we can use over partittion by to achieve this easily
=============
select firstname, lastname, location, count(location) OVER(PARTITION BY location) as total, avg(salary) OVER(PARTITION BY location) as average from employee_new;


===============================================
ROW NUMBER
===========
select firstname, lastname, salary, row_number() over (order by salary desc) from employee_new;

row_number always has order by 

want to find 5th highest salary?

select * from (
select firstname, lastname, salary, row_number() over (order by salary desc) as rank from employee_new) temptable where rank = 5;

assign row number fro partitions based on each loaction and order by salary; 

 select firstname, lastname, location,row_number() over(partition by location order by salary desc) from employee_new;
 
 ==================================
 find highest salary getters at each location
 
 select firstname, lastname from (select firstname, lastname, location,row_number() over(partition by location order by salary desc) as rownum from employee_new) temptable where rownum = 1;

========
=============================================
rank () 
=================
rank is similar to row_number but in row_number if the number is same it gives different number but rank gives same number for same value
==============

dense_rank()
==============
if there are no duplicates then row_number, rank and dense rank lead to similar result

only the differnece comes when there arfe duplicates..

rank - for duplicates same rank is assigned and the for the next entry it skip the ranks

dense_rank - it doesnt skip anyt rank in between

whenever ypu dont have duplicates use row_num
there is some competition
top 3 candidates who scord the highest marks
want to find top three position
score	dense_rank	rank
100 	-1		1
100 	-1		1
98 	-2		3
97 	-3		4
97 	-3		4
96	-4		6

====================================

--adding the flavour of partitions

select *, row_number() over (partition by location order by salary desc) from employee_new;

======================================================
Common Table expression (CTE)
==============================

This is to simplify the complex queries.
It improves the readability of a query.

Orders Table
============
order_id, order_data, order_customer_id, order_status

Total orders each customers has placed


find average number of numbers placed by each cutomer

Solution (Sub query)

select avg(total_customer_per_customer) as avg_total_customer_per_customer from (select order_customer_id, count(*) as total_order_per_customer from orders group by order_customer_id);

Solution (CTE/ With Clause)

With total_orders (order_customer_id, total_order_per_customer) as 
(select order_customer_id, count(*) as total_order_per_customer from orders group by order_customer_id)
Select avg(total_order_per_customer) as avg_total_order_per_customer from total_orders

query3(query2(query(1))) --> subquery

CTE
===
query1
query2
query3


I want to find preminum customers who plascecs more orddrs than average number of order
==========================

Solution1:(subquery) 

Select * from (select order_customer_id, count(*) as total_order_per_customer from orders group by order_customer_id) total_orders

join

(select avg(total_customer_per_customer) as avg_total_customer_per_customer from (select order_customer_id, count(*) as total_order_per_customer from orders group by order_customer_id)) average_order

 total_orders.total_order_per_customer > average_order.avg_total_customer_per_customer;
 
 ====================
 Solution2: (CTE)
 3 Steps:
 1: calculate total orders per customer
 2: calculate average order of customer
 3: get to know which customer is premimum
 
 With total_orders (order_customer_id, total_order_per_customer) as 
 (select order_customer_id, count(*) as total_order_per_customer from orders group by order_customer_id),
 average_orders(avg_total_order_per_customer) as 
 (select avg(total_order_per_customer) as avg_total_order_per_customer from total_orders)
 select * from total_orders join average_orders on total_orders.total_order_per_customer > average_orders.avg_total_order_per_customer;


We must use query after with clause
We can use the assignment only in the immediate query
CTE defines the temporary result that uoutcan refer in select, insert, update delete statement immediate follows the CTE

CTE canimprove the performance but not always
 
 ==========================================
 Order of Executtion in SQL
 ==========================
 
 Orders Table
 ==============
 order_id(PK), order_date, customer_id, order_status
 
 Customer Table
 ===============
 customer_id(PK) customer_fname, customer_lname, username, password, address, city
 
 Select order_id, customer_id, from orders where order_id=5;
 
 seek and scan
 =============
 
 seek is generally quite faster than scan
 
 1
 7
 4
 8
 2
 9
 10
 3
  if N element then we have to search N element int the worst case
  O(N)
  
  1
  2
  3
  4
  7
  8
  9
  10
  
  if it is sorted it is easy to serarch
  
  Primary Key
  ===========
  order_id(clustered)
  clustered -> Records will be physically ordered in the actual table
  =========
  
  
  id = 4
  order_id = 5 (3 more columns)
  id = 6
 seek -->quickly  able to search due to sorted data done in index
 scan -->cannot quickly search, search by scanning every record
 
 clustered index Vs non Clustered index
 ======================================
 
 composite clustered index (order_id, customer_id)
 
 clustered index (order_id)
 
 non clustered index -->any number of column overhead due to 
 
 select city, count(*) as total from orders join customers on orders.customer_id = customer.customer_id where order_status != 'PENDING_STATUS' group by city having count(*) >10 order by total desc;
 
 Read the plan right to left and form top to bottom
 
 from, join
 
 where
 
 group by
 
 having
 
 select (alias is done here so alias cannot be done in having clause)
 
 order by
 
 limit
 
!!!there may be the cases that doednt follow the above execution

 select city, count(*) as total from orders join customers on orders.customer_id = customer.customer_id where order_status != 'PENDING_STATUS' group by city having city = 'Phoenix' order by total desc;
 
  select top 3 city, count(*) as total from orders join customers on orders.customer_id = customer.customer_id where order_status != 'PENDING_STATUS' group by city having city = 'Phoenix' order by total desc;


count(*) > 100
filter
sort

count(*) < 10
sort 
filter



=============================================================================
Seccond highest salary
======================

select max(salary) as SecondHighestSalary from employee where salary != (select max(salary) from Employee);

select ifnull ((select distinct salary from employee order by salary desc limit 1 offset 1), Null) as secondhighestsalary; 

select ifnull ((select distinct salary from (select salary, dense_rank() over(order by salary desc) as rank from employee_new)temp   where temp.rank =2),NULL) as secondHighest;


Nth highest salary
==================

select salary from employee order by salary desc limit 1 offset 1

	
consecutive 3 number

Logs table:
+----+-----+
| id | num |
+----+-----+
| 1  | 1   |
| 2  | 1   |
| 3  | 1   |
| 4  | 2   |
| 5  | 1   |
| 6  | 2   |
| 7  | 2   |
+----+-----+

select distinct num from Logs l1 
join Logs l2 on l2.id = l1.id+1 and l2.num=l1.num
join Logs l3 on l3.id = l1.id+2 and l3.num = l1.num


Employee table:
+----+-------+--------+-----------+
| id | name  | salary | managerId |
+----+-------+--------+-----------+
| 1  | Joe   | 70000  | 3         |
| 2  | Henry | 80000  | 4         |
| 3  | Sam   | 60000  | Null      |
| 4  | Max   | 90000  | Null      |
+----+-------+--------+-----------+

Write an SQL query to find the employees who earn more than their managers.

Return the result table in any order.
====================================

select name as Employee from Employee e1 
join Employee e2 on e1.managerId = e2.id and e1.salary > e2.salary


Person table:
+----+---------+
| id | email   |
+----+---------+
| 1  | a@b.com |
| 2  | c@d.com |
| 3  | a@b.com |
+----+---------+

Write an SQL query to report all the duplicate emails.
Return the result table in any order.

select email as Email from (select email, count(*) as c from Person group by email)temp where temp.c >1;


Customers table:
+----+-------+
| id | name  |
+----+-------+
| 1  | Joe   |
| 2  | Henry |
| 3  | Sam   |
| 4  | Max   |
+----+-------+
Orders table:
+----+------------+
| id | customerId |
+----+------------+
| 1  | 3          |
| 2  | 1          |
+----+------------+

Write an SQL query to report all customers who never order anything.
Return the result table in any order.

select name as 'Customers'from (select Customers.id,name,customerId  from Customers left join Orders on Customers.id =Orders.customerId)temp where temp.customerId is NULL

