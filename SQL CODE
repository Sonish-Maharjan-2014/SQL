CREATE TABLE employee(employeeid int primary key, firstname varchar(15), middlename varchar(20), lastname varchar(30), age int, salary int,location varchar(50) default 'gwarko'  not null);


CREATE TABLE employee(
employeeid int, 
firstname varchar(15), 
middlename varchar(20), 
lastname varchar(30), 
age int, 
salary int,
location varchar(50) default 'gwarko'  not null,
PRIMARY KEY(employeeid,firstname)
);

INSERT INTO employee(employeeid, firstname, middlename, lastname, age, salary, location) VALUES(1,"Ram","Kumar","Sharma",40,  40000);

SELECT * FROM employee;


CREATE TABLE employee(
employeeid int AUTO_INCREMENT, 
firstname varchar(15), 
middlename varchar(20), 
lastname varchar(30), 
age int, 
salary int,
location varchar(50) default 'gwarko'  not null,
PRIMARY KEY(employeeid,firstname)
);

Unique
============
only one primary key and primary key canno t have null value, it is use to get unique record

unique key can hold null value
mysql can hold many null but other compiler may hold only one null
 table has only one primary key but can have multiple unique key in the table
 
 
 
 
 CREATE TABLE employee(
employeeid int AUTO_INCREMENT, 
firstname varchar(15),  
lastname varchar(30), 
age int, 
PRIMARY KEY(firstname, lastname)
);

SELECT DISTINCT location FROM student;

SELECT * FROM studnet ORDER BY student_fname desc;


SELECT student_fname FROM student Order BY enrollment_date DESC LIMIT 1;


SELECT * FROM student WHERE student_fname LIKE '%/%%';

DISTINCT
==========
DISTINCT AND ORDERE BY DOESNT WORK AT THE SAME TIME

SELECT source_of_jonining FROM student;

ORDER OF EXECUTION
================
FROM (LOADING THE TABLE)

SELECT (PROJECTING source_of_joining)

SELECT source_of_joiningm enrollment_date FROM student;

SELECT source_of_joiningm enrollment_date FROM student ORDER BY enrollment_date;
================
FROM (LOADING THE TABLE)
SELECT (PROJECTING source_of_joining, enrollment_date);
ORDER BY (based on enrollment_date it will order by select source_of_joninig)


===========
SELECT DISTINCT source_of_joining FROM studnets ORDER BY enrollment_date;
ORDER OF EXECUTION
================
FROM

SELECT

DISTINCT

ORDER BY

========================================
AGGREGRATE FUNCTION
========================================
INPUT IS MANY LINE AND OUTPUT IS ONE LINE

COUNT

SELECT COUNT(*) FROM student;

SELECT COUNT(DISTINCT student_company) AS companies FROM student;

SELECT COUNT(DISTINCT source_of_joining) FROM student;

SELECT batch_date FROM student;

=====================================
GROUP BY
====================================
HOW MANY PEOPLE JOINED BY DIFFENERNT SOURCE LIKE 'FRIEND'

SELECT source_of_joining, COUNT(*) FROM student GROUP BY source_of_joining = 'friend';


location, source_of_joninig

SELECT location, source_of_joining FROM student;

SELECT location, source_of_joining, COUNT(*) FROM student GROUP BY location, source_of_joining;

SELECT selected_course, COUNT(*) FROM student GROUP BY selected_course;

=====================================
MIN & MAX
=====================================
SELECT MIN(years_of_exp) FROM student;

SELECT MAX(years_of_exp) FROM student;

Select source_of_joining, max(years_of_exp) from student group by source_of_joining;

SELECT SUM(SORCE OF JONING) FROM STUDENT;

AVG
=======
SELECT location, AVG(years_of_exp) FROM student group by location


GROUP BY
===============


data type
=============================================
Decimal
time stamp


MariaDB [trendytech]> create table course_new( courseid int not null, coursename varchar(30) not null, coursedurationmonths decimal(3,1) not null, coursefee int not null, changed_at timestamp default now() on update now()/current_timestamp(), primary key(courseid));

==========================================
Logical operator
========================
!= or <>--------> not equal to 
like and not like ----> eg: '%data%'
=
>=
>
<=
<
in
between and not betweeen -----> eg: between 8 and 12

select * from student where student_company = 'flipkart' or student_company = 'walmart' or student_company = 'microsoft';

select * from student where student_company in ('filpkart','walmart', 'microsoft');

case

select courseid,coursename,coursefee,
    -> case
    -> when coursedurationmonths > 4 then 'master'
    -> else 'diploma'
    -> end as course_type 
    -> from course_new;
    
select student_id, student_fname, student_lname, student_company,
    -> CASE
    -> WHEN student_company in ('flipkart', 'walmart', 'microsoft') then 'product_based'
    -> ELSE 'service_based'
    -> END as 'company_type'
    -> FROM student;

====================================================
JOINs
==============

tables
->student
student_fname, selected_course
->course
course_id, course_name


NESTED QUERY
================
select course_name from course where course_id = (select selected_course from student where student_fname = 'ram');

==================
select student_fname, course_name from student join course on student.selected_course = course.course_id;

BY DEFAULT join == inner join

inner join = matched in both table are only joined

outer join = every row in first table is linked with every data in second table unmatched records are set null

Left outer join
===============
all the matching record are considered + all the non matching recods in the left table which does not have match in the right

Right outer join
==============================
all the matching record are considered + all the non matching record in the right table which doesnt have mathc in the left

Full outer join (Union of left and right)
====================
all the matching record + non matchiing from left + non matching form right 

select student_fname, student_lname, course_name from student_latest right join course_latest on student_latest.selected_course = course_latest.course_id union select student_fname, student_lname, course_name from student_latest left join course_latest on student_latest.selected_course = course_latest.course_id; 


cross join
===============
select * from student join course;

=====================================================
where vs having clause in sql
===============================

select source_of_joining, count(*) as total from student group by source_of_joining;

select * from student natural join course on student.selected_course = course.course_id;

=======================================================
get data on the sourcee_of_joning
======================
select source_of_joining, count(*) as total from student group by source_of_joining

know the lead source through which student has joined
================================
select source_of_joining, count(*) as total from student group by source_of_joining where total>1;

where clause is used to filter individual record before aggregration so above query doesnt work so we use having clause

select source_of_joining, count(*) as total from student group by source_of_joining having total > 1;

having clause is use after the grouping method

only form linkdin

select source_of_joining, count(*) as total from student group by source_of_joining having source_of_joining ='linkedin';

optimized
=========
select source_of_joining, count(*) as total from student where source_of_joining ='total'
group by source_of_joining;

can we use both where and having in same query?
=========================
to know the location from which more than 1 student has joined and student experience is more than 10 years

select location, count(*) as total from student where years_of_exp > 10 group by location having total > 1;

where is used before group by and do filering on individual records

having is used after group by and do filtering on aggregrated records.

we use where and haviving in tha same query also

where is more performant than having

===========================================================

CREATE TABLE employee(
firstname varchar(40),
lastname varchar(30),
age int,
salary int,
);
========================
how many people are from each location and find average salary;
===========
select location,count(*) as total, avg(salary)  from employee_new group by location;

============
 select firstname, lastname, temptable.location,total, average from employee_new join 
(select location,count(*) as total, avg(salary) as average  from employee_new group by location) temptable 
on temptable.location = employee_new.location;

==================
we can use over partittion by to achieve this easily
=============
select firstname, lastname, location, count(location) OVER(PARTITION BY location) as total, avg(salary) OVER(PARTITION BY location) as average from employee_new;


===============================================
ROW NUMBER
===========
select firstname, lastname, salary, row_number() over (order by salary desc) from employee_new;

row_number always has order by 

want to find 5th highest salary?

select * from (
select firstname, lastname, salary, row_number() over (order by salary desc) as rank from employee_new) temptable where rank = 5;

assign row number fro partitions based on each loaction and order by salary; 

 select firstname, lastname, location,row_number() over(partition by location order by salary desc) from employee_new;
 
 ==================================
 find highest salary getters at each location
 
 select firstname, lastname from (select firstname, lastname, location,row_number() over(partition by location order by salary desc) as rownum from employee_new) temptable where rownum = 1;

========
=============================================
rank () 
=================
rank is similar to row_number but in row_number if the number is same it gives different number but rank gives same number for same value
==============

dense_rank()
==============
if there are no duplicates then row_number, rank and dense rank lead to similar result

only the differnece comes when there arfe duplicates..

rank - for duplicates same rank is assigned and the for the next entry it skip the ranks

dense_rank - it doesnt skip anyt rank in between

whenever ypu dont have duplicates use row_num
there is some competition
top 3 candidates who scord the highest marks
want to find top three position
score	dense_rank	rank
100 	-1		1
100 	-1		1
98 	-2		3
97 	-3		4
97 	-3		4
96	-4		6

====================================

--adding the flavour of partitions

select *, row_number() over (partition by location order by salary desc) from employee_new;

======================================================
Common Table expression (CTE)
==============================

This is to simplify the complex queries.
It improves the readability of a query.

Orders Table
============
order_id, order_data, order_customer_id, order_status

Total orders each customers has placed


find average number of numbers placed by each cutomer

Solution (Sub query)

select avg(total_customer_per_customer) as avg_total_customer_per_customer from (select order_customer_id, count(*) as total_order_per_customer from orders group by order_customer_id);

Solution (CTE/ With Clause)

With total_orders (order_customer_id, total_order_per_customer) as 
(select order_customer_id, count(*) as total_order_per_customer from orders group by order_customer_id)
Select avg(total_order_per_customer) as avg_total_order_per_customer from total_orders 




 









